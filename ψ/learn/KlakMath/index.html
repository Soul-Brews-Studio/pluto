<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KlakMath — 3D Visualization</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Grotesk', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            cursor: crosshair;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Overlay UI */
        .ui-overlay {
            position: fixed;
            z-index: 100;
            pointer-events: none;
        }

        .ui-overlay * {
            pointer-events: auto;
        }

        /* Header */
        .header {
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            letter-spacing: -0.03em;
            background: linear-gradient(135deg, #fff 0%, rgba(255,255,255,0.6) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 80px rgba(255,255,255,0.3);
            margin-bottom: 8px;
        }

        .header p {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.5);
            font-weight: 400;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }

        /* Mode Selector */
        .mode-selector {
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(20px);
            padding: 8px;
            border-radius: 50px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .mode-btn {
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.5);
            padding: 12px 24px;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            border-radius: 40px;
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            letter-spacing: 0.02em;
        }

        .mode-btn:hover {
            color: rgba(255,255,255,0.8);
        }

        .mode-btn.active {
            background: #fff;
            color: #000;
            box-shadow: 0 0 30px rgba(255,255,255,0.3);
        }

        /* Side Panel */
        .side-panel {
            top: 50%;
            right: 40px;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 200px;
        }

        .control-item {
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(20px);
            padding: 20px;
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.08);
        }

        .control-label {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.4);
            text-transform: uppercase;
            letter-spacing: 0.15em;
            margin-bottom: 12px;
            display: block;
        }

        .control-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            font-weight: 500;
            color: #fff;
            display: block;
            margin-bottom: 12px;
        }

        input[type="range"] {
            width: 100%;
            height: 2px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            -webkit-appearance: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(255,255,255,0.5);
            transition: transform 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.3);
        }

        /* Stats */
        .stats-panel {
            top: 40px;
            left: 40px;
        }

        .stat-row {
            display: flex;
            align-items: baseline;
            gap: 8px;
            margin-bottom: 8px;
            opacity: 0.6;
            font-size: 0.75rem;
        }

        .stat-label {
            color: rgba(255,255,255,0.4);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .stat-value {
            font-family: 'JetBrains Mono', monospace;
            color: #fff;
        }

        /* Info Panel */
        .info-panel {
            bottom: 40px;
            left: 40px;
            max-width: 300px;
        }

        .info-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: rgba(255,255,255,0.9);
        }

        .info-desc {
            font-size: 0.8rem;
            line-height: 1.6;
            color: rgba(255,255,255,0.4);
        }

        /* Loading */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.8s ease;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-text {
            font-size: 0.8rem;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            color: rgba(255,255,255,0.5);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .side-panel {
                display: none;
            }

            .header h1 {
                font-size: 1.8rem;
            }

            .info-panel {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <span class="loading-text">Initializing</span>
    </div>

    <div id="canvas-container"></div>

    <!-- Header -->
    <div class="ui-overlay header">
        <h1>KlakMath</h1>
        <p>Interactive 3D Visualization</p>
    </div>

    <!-- Stats -->
    <div class="ui-overlay stats-panel">
        <div class="stat-row">
            <span class="stat-label">FPS</span>
            <span class="stat-value" id="fps">60</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Particles</span>
            <span class="stat-value" id="particles">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Time</span>
            <span class="stat-value" id="time">0.00</span>
        </div>
    </div>

    <!-- Mode Selector -->
    <div class="ui-overlay mode-selector">
        <button class="mode-btn active" data-mode="sphere">Sphere</button>
        <button class="mode-btn" data-mode="noise">Noise Flow</button>
        <button class="mode-btn" data-mode="tween">Tween</button>
        <button class="mode-btn" data-mode="hash">XXHash</button>
    </div>

    <!-- Side Controls -->
    <div class="ui-overlay side-panel">
        <div class="control-item">
            <span class="control-label">Speed</span>
            <span class="control-value" id="speedValue">1.0</span>
            <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1">
        </div>
        <div class="control-item">
            <span class="control-label">Intensity</span>
            <span class="control-value" id="intensityValue">1.0</span>
            <input type="range" id="intensity" min="0.1" max="2" step="0.1" value="1">
        </div>
        <div class="control-item">
            <span class="control-label">Seed</span>
            <span class="control-value" id="seedValue">42</span>
            <input type="range" id="seed" min="0" max="999" step="1" value="42">
        </div>
    </div>

    <!-- Info Panel -->
    <div class="ui-overlay info-panel">
        <div class="info-title" id="infoTitle">Sphere Distribution</div>
        <div class="info-desc" id="infoDesc">
            Particles distributed uniformly on a sphere surface using XXHash deterministic random generation.
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ============================================================
        // KlakMath Implementation
        // ============================================================

        class XXHash {
            constructor(seed) {
                this.seed = seed >>> 0;
            }

            static rotl32(x, r) {
                return ((x << r) | (x >>> (32 - r))) >>> 0;
            }

            hash(data) {
                const PRIME32_1 = 2654435761;
                const PRIME32_2 = 2246822519;
                const PRIME32_3 = 3266489917;
                const PRIME32_4 = 668265263;
                const PRIME32_5 = 374761393;

                data = data >>> 0;
                let h32 = (this.seed + PRIME32_5) >>> 0;
                h32 = (h32 + 4) >>> 0;
                h32 = (h32 + Math.imul(data, PRIME32_3)) >>> 0;
                h32 = (Math.imul(XXHash.rotl32(h32, 17), PRIME32_4)) >>> 0;
                h32 ^= h32 >>> 15;
                h32 = Math.imul(h32, PRIME32_2) >>> 0;
                h32 ^= h32 >>> 13;
                h32 = Math.imul(h32, PRIME32_3) >>> 0;
                h32 ^= h32 >>> 16;
                return h32 >>> 0;
            }

            float(data, min = 0, max = 1) {
                return min + (max - min) * (this.hash(data) / 0xFFFFFFFF);
            }

            onSphere(data) {
                const phi = this.float(data, 0, Math.PI * 2);
                const z = this.float(data + 0x10000000, -1, 1);
                const w = Math.sqrt(1 - z * z);
                return new THREE.Vector3(Math.cos(phi) * w, z, Math.sin(phi) * w);
            }

            inSphere(data) {
                const p = this.onSphere(data);
                const r = Math.pow(this.float(data + 0x20000000), 1/3);
                return p.multiplyScalar(r);
            }
        }

        const Noise = {
            float(p, seed) {
                const hash = new XXHash(seed);
                const i = Math.floor(p) + 0x10000000;
                const x = p - Math.floor(p);

                let k0 = x, k1 = 1 - x;
                k0 = 1 - k0 * k0; k1 = 1 - k1 * k1;
                k0 = k0 * k0 * k0; k1 = k1 * k1 * k1;

                const g0 = hash.float(i, -1, 1);
                const g1 = hash.float(i + 1, -1, 1);

                return (k0 * g0 * x + k1 * g1 * (x - 1)) * 2.37;
            },

            fractal(p, octaves, seed) {
                let f = 0, w = 1;
                for (let i = 0; i < octaves; i++) {
                    f += w * this.float(p, seed + i);
                    p *= 2;
                    w *= 0.5;
                }
                return f;
            }
        };

        const ExpTween = {
            step(current, target, speed, dt) {
                return current + (target - current) * (1 - Math.exp(-speed * dt));
            }
        };

        const CdsTween = {
            step(x, v, target, speed, dt) {
                const n1 = v - (x - target) * (speed * speed * dt);
                const n2 = 1 + speed * dt;
                const nv = n1 / (n2 * n2);
                return { x: x + nv * dt, v: nv };
            }
        };

        // ============================================================
        // Scene Setup
        // ============================================================

        let scene, camera, renderer, composer, controls;
        let particles, particleGeometry, particleMaterial;
        let currentMode = 'sphere';
        let time = 0;
        let params = { speed: 1, intensity: 1, seed: 42 };
        let targetPositions = [];
        let velocities = [];
        let basePositions = [];

        const PARTICLE_COUNT = 8000;
        const clock = new THREE.Clock();
        let frameCount = 0;
        let fps = 60;
        let lastFpsUpdate = 0;

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.FogExp2(0x000000, 0.08);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 0, 5);

            // Renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableZoom = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.3;

            // Post Processing
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));

            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, 0.4, 0.85
            );
            bloomPass.threshold = 0;
            bloomPass.strength = 1.5;
            bloomPass.radius = 0.5;
            composer.addPass(bloomPass);

            // Create particles
            createParticles();

            // Events
            window.addEventListener('resize', onWindowResize);
            setupUI();

            // Hide loading
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 1000);

            // Start animation
            animate();
        }

        function createParticles() {
            particleGeometry = new THREE.BufferGeometry();

            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            const sizes = new Float32Array(PARTICLE_COUNT);

            const hash = new XXHash(params.seed);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const pos = hash.onSphere(i).multiplyScalar(2);
                positions[i * 3] = pos.x;
                positions[i * 3 + 1] = pos.y;
                positions[i * 3 + 2] = pos.z;

                basePositions.push(pos.clone());
                targetPositions.push(pos.clone());
                velocities.push(new THREE.Vector3(0, 0, 0));

                // Colors - gradient based on position
                const hue = hash.float(i + 1000, 0.5, 0.7);
                const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;

                sizes[i] = hash.float(i + 2000, 0.5, 1.5);
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uPixelRatio: { value: renderer.getPixelRatio() }
                },
                vertexShader: `
                    attribute float size;
                    varying vec3 vColor;
                    uniform float uTime;
                    uniform float uPixelRatio;

                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * uPixelRatio * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;

                    void main() {
                        float dist = length(gl_PointCoord - vec2(0.5));
                        if (dist > 0.5) discard;

                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        alpha = pow(alpha, 1.5);

                        vec3 glow = vColor * (1.0 + alpha * 0.5);
                        gl_FragColor = vec4(glow, alpha);
                    }
                `,
                transparent: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);

            // Add subtle grid
            const gridHelper = new THREE.GridHelper(20, 40, 0x222222, 0x111111);
            gridHelper.position.y = -3;
            scene.add(gridHelper);
        }

        function updateParticles(dt) {
            const positions = particleGeometry.attributes.position.array;
            const hash = new XXHash(params.seed);
            const speed = params.speed;
            const intensity = params.intensity;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                let target, current;

                switch (currentMode) {
                    case 'sphere':
                        // Smooth sphere distribution
                        target = hash.onSphere(i).multiplyScalar(2 * intensity);
                        positions[i3] = ExpTween.step(positions[i3], target.x, speed * 2, dt);
                        positions[i3 + 1] = ExpTween.step(positions[i3 + 1], target.y, speed * 2, dt);
                        positions[i3 + 2] = ExpTween.step(positions[i3 + 2], target.z, speed * 2, dt);
                        break;

                    case 'noise':
                        // Noise-based flow
                        const noiseScale = 0.5;
                        const basePos = basePositions[i];
                        const nx = Noise.fractal((basePos.x + time * speed) * noiseScale, 3, params.seed);
                        const ny = Noise.fractal((basePos.y + time * speed) * noiseScale, 3, params.seed + 100);
                        const nz = Noise.fractal((basePos.z + time * speed) * noiseScale, 3, params.seed + 200);

                        target = new THREE.Vector3(
                            basePos.x + nx * intensity,
                            basePos.y + ny * intensity,
                            basePos.z + nz * intensity
                        );

                        positions[i3] = ExpTween.step(positions[i3], target.x, 3, dt);
                        positions[i3 + 1] = ExpTween.step(positions[i3 + 1], target.y, 3, dt);
                        positions[i3 + 2] = ExpTween.step(positions[i3 + 2], target.z, 3, dt);
                        break;

                    case 'tween':
                        // Spring physics with random targets
                        if (Math.floor(time * speed) % 3 === 0 && Math.random() < 0.01) {
                            targetPositions[i] = hash.inSphere(i + Math.floor(time * 100)).multiplyScalar(2 * intensity);
                        }

                        target = targetPositions[i];
                        const vel = velocities[i];

                        const resultX = CdsTween.step(positions[i3], vel.x, target.x, speed * 3, dt);
                        const resultY = CdsTween.step(positions[i3 + 1], vel.y, target.y, speed * 3, dt);
                        const resultZ = CdsTween.step(positions[i3 + 2], vel.z, target.z, speed * 3, dt);

                        positions[i3] = resultX.x;
                        positions[i3 + 1] = resultY.x;
                        positions[i3 + 2] = resultZ.x;
                        vel.set(resultX.v, resultY.v, resultZ.v);
                        break;

                    case 'hash':
                        // Animated hash distribution
                        const hashTime = Math.floor(time * speed * 0.5);
                        const morphHash = new XXHash(params.seed + hashTime);

                        if (hashTime % 2 === 0) {
                            target = morphHash.onSphere(i).multiplyScalar(2 * intensity);
                        } else {
                            target = morphHash.inSphere(i).multiplyScalar(2.5 * intensity);
                        }

                        positions[i3] = ExpTween.step(positions[i3], target.x, speed, dt);
                        positions[i3 + 1] = ExpTween.step(positions[i3 + 1], target.y, speed, dt);
                        positions[i3 + 2] = ExpTween.step(positions[i3 + 2], target.z, speed, dt);
                        break;
                }
            }

            particleGeometry.attributes.position.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);

            const dt = Math.min(clock.getDelta(), 0.1);
            time += dt;

            // Update particles
            updateParticles(dt);

            // Update uniforms
            particleMaterial.uniforms.uTime.value = time;

            // Update controls
            controls.update();

            // Render
            composer.render();

            // FPS counter
            frameCount++;
            if (time - lastFpsUpdate >= 0.5) {
                fps = Math.round(frameCount / (time - lastFpsUpdate));
                frameCount = 0;
                lastFpsUpdate = time;
                document.getElementById('fps').textContent = fps;
            }

            document.getElementById('particles').textContent = PARTICLE_COUNT.toLocaleString();
            document.getElementById('time').textContent = time.toFixed(2);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            particleMaterial.uniforms.uPixelRatio.value = renderer.getPixelRatio();
        }

        function setupUI() {
            // Mode buttons
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentMode = btn.dataset.mode;
                    updateInfo();
                });
            });

            // Sliders
            document.getElementById('speed').addEventListener('input', (e) => {
                params.speed = parseFloat(e.target.value);
                document.getElementById('speedValue').textContent = params.speed.toFixed(1);
            });

            document.getElementById('intensity').addEventListener('input', (e) => {
                params.intensity = parseFloat(e.target.value);
                document.getElementById('intensityValue').textContent = params.intensity.toFixed(1);
            });

            document.getElementById('seed').addEventListener('input', (e) => {
                params.seed = parseInt(e.target.value);
                document.getElementById('seedValue').textContent = params.seed;
                regenerateBasePositions();
            });
        }

        function regenerateBasePositions() {
            const hash = new XXHash(params.seed);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                basePositions[i] = hash.onSphere(i).multiplyScalar(2);
                targetPositions[i] = basePositions[i].clone();
            }
        }

        function updateInfo() {
            const info = {
                sphere: {
                    title: 'Sphere Distribution',
                    desc: 'Uniform distribution of particles on a sphere surface using XXHash deterministic random generation. Each particle position is calculated from hash values.'
                },
                noise: {
                    title: 'Noise Flow Field',
                    desc: 'Particles move through a 3D noise flow field using fractal gradient noise. Multiple octaves create organic, turbulent motion patterns.'
                },
                tween: {
                    title: 'Spring Physics',
                    desc: 'CdsTween critically damped spring interpolation. Particles smoothly transition to random targets with natural momentum and no overshoot.'
                },
                hash: {
                    title: 'XXHash Animation',
                    desc: 'Morphing between different hash-based distributions. Demonstrates deterministic randomness — same seed always produces identical results.'
                }
            };

            const data = info[currentMode];
            document.getElementById('infoTitle').textContent = data.title;
            document.getElementById('infoDesc').textContent = data.desc;
        }

        // Initialize
        init();
    </script>
</body>
</html>
