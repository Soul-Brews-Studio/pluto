<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KlakMath Music Visualizer + Gesture Control</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Space Grotesk', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }

        #canvas-container {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }

        /* Camera Preview */
        #camera-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 240px;
            height: 180px;
            border-radius: 16px;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.2);
            z-index: 200;
            background: #000;
        }

        #camera-container.hidden { display: none; }

        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #hand-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            transform: scaleX(-1);
        }

        /* Gesture Display */
        .gesture-display {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8rem;
            z-index: 150;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            text-shadow: 0 0 60px rgba(255,255,255,0.5);
        }

        .gesture-display.show { opacity: 1; }

        .ui-overlay {
            position: fixed;
            z-index: 100;
            pointer-events: none;
        }

        .ui-overlay * { pointer-events: auto; }

        /* Header */
        .header {
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        .header h1 {
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(135deg, #fff 0%, rgba(255,255,255,0.5) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header p {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.4);
            letter-spacing: 0.15em;
            text-transform: uppercase;
        }

        /* Stats Panel */
        .stats-panel {
            top: 30px;
            left: 30px;
        }

        .stat-row {
            display: flex;
            align-items: baseline;
            gap: 8px;
            margin-bottom: 6px;
            font-size: 0.7rem;
        }

        .stat-label {
            color: rgba(255,255,255,0.3);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .stat-value {
            font-family: 'JetBrains Mono', monospace;
            color: rgba(255,255,255,0.7);
        }

        .stat-value.gesture {
            color: #4ade80;
            font-size: 0.9rem;
        }

        /* Control Hint */
        .control-hint {
            bottom: 220px;
            right: 20px;
            width: 240px;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            font-size: 0.75rem;
        }

        .control-hint h3 {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 10px;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            color: rgba(255,255,255,0.6);
        }

        .control-row .emoji { font-size: 1.2rem; }

        /* Mode Selector */
        .mode-selector {
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 6px;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(20px);
            padding: 6px;
            border-radius: 50px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .mode-btn {
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.5);
            padding: 10px 20px;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            border-radius: 40px;
            transition: all 0.3s ease;
        }

        .mode-btn:hover { color: rgba(255,255,255,0.8); }
        .mode-btn.active { background: #fff; color: #000; }

        /* Start Button */
        .start-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 500;
            transition: opacity 0.5s ease;
        }

        .start-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .start-overlay h2 {
            font-size: 1.8rem;
            margin-bottom: 15px;
        }

        .start-overlay p {
            color: rgba(255,255,255,0.5);
            margin-bottom: 30px;
            max-width: 400px;
            text-align: center;
            line-height: 1.6;
        }

        .btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            padding: 16px 32px;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            border-radius: 50px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .btn:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }

        .btn.primary {
            background: #fff;
            color: #000;
        }

        .btn svg { width: 20px; height: 20px; }

        /* Status indicator */
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ef4444;
            animation: pulse 2s infinite;
        }

        .status-dot.active { background: #4ade80; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <!-- Start Overlay -->
    <div class="start-overlay" id="startOverlay">
        <h2>üéµ Music + Gesture Visualizer</h2>
        <p>Control the visualizer with your hands! Uses your camera to detect gestures and microphone for audio.</p>
        <button class="btn primary" id="startBtn">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polygon points="5 3 19 12 5 21 5 3"/>
            </svg>
            Start Experience
        </button>
    </div>

    <div id="canvas-container"></div>

    <!-- Gesture Emoji Display -->
    <div class="gesture-display" id="gestureEmoji">‚úä</div>

    <!-- Camera Preview -->
    <div id="camera-container" class="hidden">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="hand-canvas"></canvas>
    </div>

    <!-- Header -->
    <div class="ui-overlay header">
        <h1>Music + Gesture</h1>
        <p>KlakMath Powered</p>
    </div>

    <!-- Stats -->
    <div class="ui-overlay stats-panel">
        <div class="stat-row">
            <span class="stat-label">Gesture</span>
            <span class="stat-value gesture" id="currentGesture">None</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Hand</span>
            <span class="stat-value" id="handStatus">Not detected</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Bass</span>
            <span class="stat-value" id="bass">0.00</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">State</span>
            <span class="stat-value" id="playState">Playing</span>
        </div>
    </div>

    <!-- Control Hints -->
    <div class="ui-overlay control-hint">
        <h3>Gesture Controls</h3>
        <div class="control-row">
            <span class="emoji">‚úä</span>
            <span>Fist = Pause / Freeze</span>
        </div>
        <div class="control-row">
            <span class="emoji">üñêÔ∏è</span>
            <span>Open Palm = Play / Resume</span>
        </div>
        <div class="control-row">
            <span class="emoji">üëÜ</span>
            <span>Point = Next Mode</span>
        </div>
        <div class="control-row">
            <span class="emoji">‚úåÔ∏è</span>
            <span>Peace = Toggle Colors</span>
        </div>
    </div>

    <!-- Mode Selector -->
    <div class="ui-overlay mode-selector">
        <button class="mode-btn active" data-mode="sphere">Sphere</button>
        <button class="mode-btn" data-mode="bars">Bars</button>
        <button class="mode-btn" data-mode="wave">Wave</button>
        <button class="mode-btn" data-mode="galaxy">Galaxy</button>
    </div>

    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.min.js"></script>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ============================================================
        // KlakMath
        // ============================================================

        class XXHash {
            constructor(seed) { this.seed = seed >>> 0; }
            hash(data) {
                const P1=2654435761, P2=2246822519, P3=3266489917, P4=668265263, P5=374761393;
                data = data >>> 0;
                let h = (this.seed + P5 + 4) >>> 0;
                h = (h + Math.imul(data, P3)) >>> 0;
                h = (Math.imul(((h << 17) | (h >>> 15)), P4)) >>> 0;
                h ^= h >>> 15; h = Math.imul(h, P2) >>> 0;
                h ^= h >>> 13; h = Math.imul(h, P3) >>> 0;
                return (h ^ (h >>> 16)) >>> 0;
            }
            float(data, min=0, max=1) { return min + (max-min) * (this.hash(data) / 0xFFFFFFFF); }
            onSphere(data) {
                const phi = this.float(data, 0, Math.PI * 2);
                const z = this.float(data + 0x10000000, -1, 1);
                const w = Math.sqrt(1 - z * z);
                return new THREE.Vector3(Math.cos(phi) * w, z, Math.sin(phi) * w);
            }
        }

        const Noise = {
            float(p, seed) {
                const hash = new XXHash(seed);
                const i = Math.floor(p) + 0x10000000;
                const x = p - Math.floor(p);
                let k0 = x, k1 = 1 - x;
                k0 = 1 - k0*k0; k1 = 1 - k1*k1;
                k0 = k0*k0*k0; k1 = k1*k1*k1;
                return (k0 * hash.float(i,-1,1) * x + k1 * hash.float(i+1,-1,1) * (x-1)) * 2.37;
            },
            fractal(p, oct, seed) {
                let f=0, w=1;
                for(let i=0; i<oct; i++) { f += w * this.float(p, seed+i); p *= 2; w *= 0.5; }
                return f;
            }
        };

        const ExpTween = {
            step: (cur, tar, spd, dt) => cur + (tar - cur) * (1 - Math.exp(-spd * dt))
        };

        // ============================================================
        // Gesture Detection (Transfer Learning from MediaPipe)
        // ============================================================

        /**
         * LANDMARK INDICES:
         *   8   12  16  20   <- Fingertips
         *   |   |   |   |
         *   7   11  15  19
         *   |   |   |   |
         *   6   10  14  18   <- Base joints (PIP)
         *   |   |   |   |
         *   5---9---13--17   <- MCP joints
         *        \  |  /
         *         \ | /
         *          \|/
         *           0        <- Wrist
         *
         * Thumb: 1-4 (tip=4)
         */

        function distance2D(lm1, lm2) {
            return Math.sqrt((lm1.x - lm2.x)**2 + (lm1.y - lm2.y)**2);
        }

        // ============================================================
        // TODO(human): Implement gesture detection functions
        // ============================================================

        function detectFist(landmarks) {
            /**
             * CHALLENGE: Detect closed fist
             *
             * Logic:
             * - Fingertips (8, 12, 16, 20) should be BELOW base joints (6, 10, 14, 18)
             * - "Below" = higher Y value (Y increases downward)
             *
             * Steps:
             * 1. Count how many fingers are "closed" (tip.y > base.y)
             * 2. If 4 fingers closed ‚Üí fist detected
             * 3. Return { name: 'fist', confidence: closedCount / 4 }
             */

            // Finger tip and base indices
            const fingers = [
                { tip: 8, base: 6 },   // Index
                { tip: 12, base: 10 }, // Middle
                { tip: 16, base: 14 }, // Ring
                { tip: 20, base: 18 }, // Pinky
            ];

            let closedCount = 0;

            for (const finger of fingers) {
                // Tip is below base (Y increases downward) = finger is closed
                if (landmarks[finger.tip].y > landmarks[finger.base].y) {
                    closedCount++;
                }
            }

            // Thumb check: tip (4) should be close to index base (5)
            const thumbClosed = distance2D(landmarks[4], landmarks[5]) < 0.1;
            if (thumbClosed) closedCount += 0.5;

            const confidence = closedCount / 4.5;
            return confidence > 0.7 ? { name: 'fist', confidence } : null;
        }

        function detectOpenPalm(landmarks) {
            /**
             * CHALLENGE: Detect open palm (all fingers extended)
             *
             * Logic:
             * - All fingertips should be ABOVE base joints (extended)
             * - Fingertips should be far from wrist
             *
             * Steps:
             * 1. Check each finger: tip.y < base.y (extended)
             * 2. Check distance from fingertip to wrist > threshold
             * 3. Return { name: 'open_palm', confidence }
             */

            const fingers = [
                { tip: 8, base: 6 },
                { tip: 12, base: 10 },
                { tip: 16, base: 14 },
                { tip: 20, base: 18 },
            ];

            let extendedCount = 0;
            const wrist = landmarks[0];

            for (const finger of fingers) {
                // Tip is above base (Y decreases upward) = finger extended
                const isExtended = landmarks[finger.tip].y < landmarks[finger.base].y;
                // Also check distance from wrist
                const farFromWrist = distance2D(landmarks[finger.tip], wrist) > 0.15;

                if (isExtended && farFromWrist) {
                    extendedCount++;
                }
            }

            // Thumb: check if extended (far from palm center)
            const palmCenter = landmarks[9]; // Middle MCP
            const thumbExtended = distance2D(landmarks[4], palmCenter) > 0.1;
            if (thumbExtended) extendedCount += 1;

            const confidence = extendedCount / 5;
            return confidence > 0.7 ? { name: 'open_palm', confidence } : null;
        }

        function detectPoint(landmarks) {
            /**
             * CHALLENGE: Detect pointing (only index extended)
             *
             * Logic:
             * - Index (8) extended
             * - Middle (12), Ring (16), Pinky (20) closed
             */

            const indexExtended = landmarks[8].y < landmarks[6].y;
            const middleClosed = landmarks[12].y > landmarks[10].y;
            const ringClosed = landmarks[16].y > landmarks[14].y;
            const pinkyClosed = landmarks[20].y > landmarks[18].y;

            if (indexExtended && middleClosed && ringClosed && pinkyClosed) {
                return { name: 'point', confidence: 0.9 };
            }
            return null;
        }

        function detectPeace(landmarks) {
            /**
             * CHALLENGE: Detect peace sign (index + middle extended)
             */

            const indexExtended = landmarks[8].y < landmarks[6].y;
            const middleExtended = landmarks[12].y < landmarks[10].y;
            const ringClosed = landmarks[16].y > landmarks[14].y;
            const pinkyClosed = landmarks[20].y > landmarks[18].y;

            if (indexExtended && middleExtended && ringClosed && pinkyClosed) {
                return { name: 'peace', confidence: 0.9 };
            }
            return null;
        }

        function detectGestures(landmarks) {
            const detectors = [detectFist, detectOpenPalm, detectPoint, detectPeace];
            const results = [];

            for (const detector of detectors) {
                const result = detector(landmarks);
                if (result && result.confidence > 0.6) {
                    results.push(result);
                }
            }

            // Return highest confidence gesture
            if (results.length > 0) {
                return results.reduce((a, b) => a.confidence > b.confidence ? a : b);
            }
            return null;
        }

        // ============================================================
        // Audio Analyzer
        // ============================================================

        class AudioAnalyzer {
            constructor() {
                this.audioContext = null;
                this.analyser = null;
                this.dataArray = null;
                this.isActive = false;
                this.smoothedBass = 0;
                this.smoothedMid = 0;
                this.smoothedHigh = 0;
            }

            async init() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: { echoCancellation: false, noiseSuppression: false }
                    });
                    this.audioContext = new AudioContext();
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 512;
                    this.analyser.smoothingTimeConstant = 0.8;
                    this.audioContext.createMediaStreamSource(stream).connect(this.analyser);
                    this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                    this.isActive = true;
                    return true;
                } catch (e) {
                    console.error('Audio init failed:', e);
                    return false;
                }
            }

            update(sensitivity = 1) {
                if (!this.isActive) return;
                this.analyser.getByteFrequencyData(this.dataArray);
                const len = this.dataArray.length;
                const bassEnd = Math.floor(len * 0.1);
                const midEnd = Math.floor(len * 0.5);

                let bass = 0, mid = 0, high = 0;
                for (let i = 0; i < bassEnd; i++) bass += this.dataArray[i];
                for (let i = bassEnd; i < midEnd; i++) mid += this.dataArray[i];
                for (let i = midEnd; i < len; i++) high += this.dataArray[i];

                bass = (bass / bassEnd / 255) * sensitivity;
                mid = (mid / (midEnd - bassEnd) / 255) * sensitivity;
                high = (high / (len - midEnd) / 255) * sensitivity;

                this.smoothedBass = this.smoothedBass * 0.8 + bass * 0.2;
                this.smoothedMid = this.smoothedMid * 0.8 + mid * 0.2;
                this.smoothedHigh = this.smoothedHigh * 0.8 + high * 0.2;
            }

            getBass() { return this.smoothedBass; }
            getMid() { return this.smoothedMid; }
            getHigh() { return this.smoothedHigh; }
            getFrequencyData() { return this.dataArray || new Uint8Array(256); }
        }

        // ============================================================
        // Main App
        // ============================================================

        let scene, camera, renderer, composer, controls;
        let particles, particleGeometry, particleMaterial;
        let bars = [], barGroup;
        let audioAnalyzer;
        let currentMode = 'sphere';
        let time = 0;
        let isPaused = false;
        let colorShift = 0;
        let basePositions = [];

        const PARTICLE_COUNT = 5000;
        const BAR_COUNT = 64;
        const clock = new THREE.Clock();

        // Gesture state
        let currentGesture = null;
        let lastGestureTime = 0;
        const GESTURE_COOLDOWN = 500; // ms

        const gestureEmojis = {
            fist: '‚úä',
            open_palm: 'üñêÔ∏è',
            point: 'üëÜ',
            peace: '‚úåÔ∏è'
        };

        function init() {
            audioAnalyzer = new AudioAnalyzer();

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000508);
            scene.fog = new THREE.FogExp2(0x000508, 0.06);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 2, 6);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            // Post Processing
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            composer.addPass(new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, 0.5, 0.1
            ));

            createParticles();
            createBars();

            window.addEventListener('resize', onResize);
            setupUI();

            animate();
        }

        function createParticles() {
            particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            const sizes = new Float32Array(PARTICLE_COUNT);
            const hash = new XXHash(42);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const pos = hash.onSphere(i).multiplyScalar(2);
                positions[i*3] = pos.x;
                positions[i*3+1] = pos.y;
                positions[i*3+2] = pos.z;
                basePositions.push(pos.clone());

                const hue = hash.float(i + 1000, 0.5, 0.8);
                const color = new THREE.Color().setHSL(hue, 0.9, 0.6);
                colors[i*3] = color.r;
                colors[i*3+1] = color.g;
                colors[i*3+2] = color.b;
                sizes[i] = hash.float(i + 2000, 0.3, 1.2);
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            particleMaterial = new THREE.ShaderMaterial({
                uniforms: { uBass: { value: 0 }, uPixelRatio: { value: renderer.getPixelRatio() } },
                vertexShader: `
                    attribute float size;
                    varying vec3 vColor;
                    uniform float uBass;
                    uniform float uPixelRatio;
                    void main() {
                        vColor = color;
                        vec3 pos = position * (1.0 + uBass * 0.5);
                        vec4 mv = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = size * uPixelRatio * (250.0 / -mv.z) * (1.0 + uBass);
                        gl_Position = projectionMatrix * mv;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        float d = length(gl_PointCoord - 0.5);
                        if (d > 0.5) discard;
                        gl_FragColor = vec4(vColor * 1.5, pow(1.0 - d * 2.0, 2.0));
                    }
                `,
                transparent: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
        }

        function createBars() {
            barGroup = new THREE.Group();
            const radius = 3;

            for (let i = 0; i < BAR_COUNT; i++) {
                const angle = (i / BAR_COUNT) * Math.PI * 2;
                const geo = new THREE.BoxGeometry(0.15, 1, 0.15);
                const mat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(i / BAR_COUNT, 0.8, 0.5),
                    transparent: true, opacity: 0.9
                });
                const bar = new THREE.Mesh(geo, mat);
                bar.position.x = Math.cos(angle) * radius;
                bar.position.z = Math.sin(angle) * radius;
                bar.rotation.y = -angle;
                bars.push(bar);
                barGroup.add(bar);
            }

            barGroup.visible = false;
            scene.add(barGroup);
        }

        // ============================================================
        // Gesture Handlers
        // ============================================================

        function handleGesture(gesture) {
            if (!gesture) return;

            const now = Date.now();
            if (now - lastGestureTime < GESTURE_COOLDOWN) return;

            // Update display
            document.getElementById('currentGesture').textContent = gesture.name;
            const emojiEl = document.getElementById('gestureEmoji');
            emojiEl.textContent = gestureEmojis[gesture.name] || '‚ùì';
            emojiEl.classList.add('show');
            setTimeout(() => emojiEl.classList.remove('show'), 800);

            // Execute gesture action
            switch (gesture.name) {
                case 'fist':
                    isPaused = true;
                    controls.autoRotate = false;
                    document.getElementById('playState').textContent = 'Paused ‚úä';
                    break;

                case 'open_palm':
                    isPaused = false;
                    controls.autoRotate = true;
                    document.getElementById('playState').textContent = 'Playing üñêÔ∏è';
                    break;

                case 'point':
                    // Cycle to next mode
                    const modes = ['sphere', 'bars', 'wave', 'galaxy'];
                    const currentIdx = modes.indexOf(currentMode);
                    const nextIdx = (currentIdx + 1) % modes.length;
                    setMode(modes[nextIdx]);
                    break;

                case 'peace':
                    // Toggle color shift
                    colorShift += 0.3;
                    break;
            }

            lastGestureTime = now;
        }

        function setMode(mode) {
            currentMode = mode;
            particles.visible = mode === 'sphere' || mode === 'galaxy';
            barGroup.visible = mode === 'bars';

            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });
        }

        // ============================================================
        // Update & Render
        // ============================================================

        function updateVisualizer(dt) {
            if (isPaused) return;

            audioAnalyzer.update(1.5);
            const bass = audioAnalyzer.getBass();
            const freqData = audioAnalyzer.getFrequencyData();

            document.getElementById('bass').textContent = bass.toFixed(2);

            const positions = particleGeometry.attributes.position.array;
            const colors = particleGeometry.attributes.color.array;
            const hash = new XXHash(42);
            const hueShift = time * 0.1 + colorShift;

            if (currentMode === 'sphere' || currentMode === 'galaxy') {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const base = basePositions[i];
                    const freqIndex = Math.floor(hash.float(i, 0, 1) * freqData.length);
                    const freqValue = freqData[freqIndex] / 255;

                    let scale = 2 + freqValue * 1.5;

                    if (currentMode === 'galaxy') {
                        const t = i / PARTICLE_COUNT;
                        const angle = t * Math.PI * 8 + time * 0.2;
                        const radius = 0.5 + t * 3;
                        const heightOffset = Noise.fractal(t * 10 + time, 2, i) * (0.5 + freqValue);

                        positions[i*3] = ExpTween.step(positions[i*3], Math.cos(angle) * radius, 5, dt);
                        positions[i*3+1] = ExpTween.step(positions[i*3+1], heightOffset, 5, dt);
                        positions[i*3+2] = ExpTween.step(positions[i*3+2], Math.sin(angle) * radius, 5, dt);
                    } else {
                        positions[i*3] = ExpTween.step(positions[i*3], base.x * scale, 8, dt);
                        positions[i*3+1] = ExpTween.step(positions[i*3+1], base.y * scale, 8, dt);
                        positions[i*3+2] = ExpTween.step(positions[i*3+2], base.z * scale, 8, dt);
                    }

                    // Color
                    const hue = (hash.float(i + 1000, 0.5, 0.8) + hueShift + freqValue * 0.2) % 1;
                    const color = new THREE.Color().setHSL(hue, 0.9, 0.5 + freqValue * 0.3);
                    colors[i*3] = color.r;
                    colors[i*3+1] = color.g;
                    colors[i*3+2] = color.b;
                }

                particleMaterial.uniforms.uBass.value = bass;
                particles.rotation.y += dt * 0.1 * (1 + bass);

            } else if (currentMode === 'bars') {
                const step = Math.floor(freqData.length / BAR_COUNT);
                bars.forEach((bar, i) => {
                    const value = freqData[i * step] / 255;
                    bar.scale.y = ExpTween.step(bar.scale.y, 0.2 + value * 4, 15, dt);
                    bar.position.y = bar.scale.y / 2;
                    bar.material.color.setHSL((i / BAR_COUNT + hueShift) % 1, 0.8, 0.4 + value * 0.4);
                });
                barGroup.rotation.y += dt * 0.2 * (1 + bass);
            }

            particleGeometry.attributes.position.needsUpdate = true;
            particleGeometry.attributes.color.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);

            const dt = Math.min(clock.getDelta(), 0.1);
            if (!isPaused) time += dt;

            updateVisualizer(dt);
            controls.update();
            composer.render();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============================================================
        // MediaPipe Hand Tracking
        // ============================================================

        async function initHandTracking() {
            const video = document.getElementById('webcam');
            const canvas = document.getElementById('hand-canvas');
            const ctx = canvas.getContext('2d');

            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0, // Lite model for speed
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults((results) => {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    document.getElementById('handStatus').textContent = 'Detected ‚úì';

                    // Draw landmarks
                    ctx.fillStyle = '#4ade80';
                    for (const lm of landmarks) {
                        ctx.beginPath();
                        ctx.arc(lm.x * canvas.width, lm.y * canvas.height, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Detect and handle gesture
                    const gesture = detectGestures(landmarks);
                    handleGesture(gesture);

                } else {
                    document.getElementById('handStatus').textContent = 'Not detected';
                    document.getElementById('currentGesture').textContent = 'None';
                }
            });

            // Start camera
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            await video.play();

            const camera = new Camera(video, {
                onFrame: async () => {
                    await hands.send({ image: video });
                },
                width: 320,
                height: 240
            });

            camera.start();
            document.getElementById('camera-container').classList.remove('hidden');
        }

        // ============================================================
        // UI Setup
        // ============================================================

        function setupUI() {
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', () => setMode(btn.dataset.mode));
            });

            document.getElementById('startBtn').addEventListener('click', async () => {
                document.getElementById('startOverlay').classList.add('hidden');

                // Init audio
                await audioAnalyzer.init();

                // Init hand tracking
                try {
                    await initHandTracking();
                } catch (e) {
                    console.error('Hand tracking failed:', e);
                }
            });
        }

        // Start
        init();
    </script>
</body>
</html>
